Logical Optimization: This phase optimizes the operations without considering the specifics of how they will be physically executed. It focuses on restructuring and reordering the operations in a SQL statement to create a more efficient, equivalent execution. The goal is to reduce the size of the data set involved in the query as much as possible, as quickly as possible. Examples of logical optimization include predicate pushdown, algebraic simplifications, or transforming outer joins into inner joins when appropriate.

Physical Optimization: This phase takes the logically optimized plan and focuses on how to actually perform the operations given the specifics of the database architecture, like indexes, storage layout, memory size, and data distribution. It creates an execution plan that the database engine follows to gather the requested data. The physical optimization phase might choose strategies like table scans or index scans, nested loop joins or hash joins, etc., based on cost estimations of different possible plans.


### Sql layer

Session context - SQL ->  Parser - AST -> Validator - AST -> Type infer - AST -> Logical Optimizer - Logical plan -> Physical Optimizer - Physical plan -> Local executor and distributed executor

#### packages

tidb: layer between protocal and sql
parser: syntatical analysis
plan: validate + generate query plan + optimize query plan
executor: generate executor and execute
distsql: send request to tikv via tikv client 

SQL layer is the most complicated in the tidb layer because
* inherent complexity of SQL
* Choose a good query plan
* deal with a distributed storage engine

Parser generated by yacc

```go
    type SelectStmt struct {
        dmlNode
        resultSetNode
        // SelectStmtOpts wraps around select hints and switches.
        *SelectStmtOpts
        // Distinct represents whether the select has distinct option.
        Distinct bool
        // From is the from clause of the query.
        From *TableRefsClause
        // Where is the where clause in select statement.
        Where ExprNode
        // Fields is the select expression list.
        Fields *FieldList
        // GroupBy is the group by expression list.
        GroupBy *GroupByClause
        // Having is the having condition.
        Having *HavingClause
        // OrderBy is the ordering expression list.
        OrderBy *OrderByClause
        // Limit is the limit clause.
        Limit *Limit
        // LockTp is the lock type
        LockTp SelectLockType
        // TableHints represents the level Optimizer Hint
        TableHints []*TableOptimizerHint
    }
```

All statements abstracted to ast.StmtNode, and most implemented ast.Node to Accept() a visitor. Follow up processing are done to the visitor    

```go

func (c *Compiler) Compile(goCtx goctx.Context, stmtNode ast.StmtNode) (*ExecStmt, error) {
	if span := opentracing.SpanFromContext(goCtx); span != nil {
		span1 := opentracing.StartSpan("executor.Compile", opentracing.ChildOf(span.Context()))
		defer span1.Finish()
	}

	infoSchema := GetInfoSchema(c.Ctx)
	if err := plan.Preprocess(c.Ctx, stmtNode, infoSchema, false); err != nil {
		return nil, errors.Trace(err)
	}

///make and optimize the query plan
	finalPlan, err := plan.Optimize(c.Ctx, stmtNode, infoSchema)
	if err != nil {
		return nil, errors.Trace(err)
	}

	CountStmtNode(stmtNode, c.Ctx.GetSessionVars().InRestrictedSQL)
	isExpensive := logExpensiveQuery(stmtNode, finalPlan)

///Follow up execution based on it
	return &ExecStmt{
		InfoSchema: infoSchema,
		Plan:       finalPlan,
		Expensive:  isExpensive,
		Cacheable:  plan.Cacheable(stmtNode),
		Text:       stmtNode.Text(),
		StmtNode:   stmtNode,
		Ctx:        c.Ctx,
	}, nil
}


```go

type InsertStmt struct {
    dmlNode
    IsReplace   bool
    IgnoreErr   bool
    Table       *TableRefsClause
    Columns     [](#)*ColumnName
    Lists       [](#)[](#)ExprNode
    Setlist     [](#)*Assignment
    Priority    mysql.PriorityEnum
    OnDuplicate [](#)*Assignment
    Select



```


```
// Insert represents an insert plan.
type Insert struct {
	baseSchemaProducer

	Table       table.Table
	tableSchema *expression.Schema
	Columns     []*ast.ColumnName
	Lists       [][]expression.Expression
	Setlist     []*expression.Assignment
	OnDuplicate []*expression.Assignment

	IsReplace bool
	Priority  mysql.PriorityEnum
	IgnoreErr bool

	// NeedFillDefaultValue is true when expr in value list reference other column.
	NeedFillDefaultValue bool

	GenCols InsertGeneratedColumns

	SelectPlan PhysicalPlan
}

```




Build in Makefile

### Packages

#### ast
data structure for AST, e.g., SelectStmt defines what data structure holds a select

#### context
Many packages and functions rely on this

#### (Important) distsql
Abstract distributed computing interface

#### domain

Abstract the storage, somewhat similar to namespace. Each tidb instance creates only 1 Domain instance

#### (Important) executor

Complicated


#### (Important) expression

* Operator and builtin functions
* aggregation: For sum, count etc


#### model

* Sql metadata,  DBInfo/TableInfo/ColumnInfo/IndexInfo 


#### parser

* Turn sql into AST
* lexer.go and parser.y
* goyacc: Package goyacc
* opcode: constants on the operation


#### (Important) plan
* Query optimization


#### table

* Abstract the table
* Tables: implement the defined interface  

#### tablecodec

* SQL to Key-Value


#### tidb-server
* Service's main





